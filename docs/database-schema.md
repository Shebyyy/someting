# Database Schema

Complete database schema documentation for Commentum Shelby.

## Table of Contents

1. [Overview](#overview)
2. [Core Tables](#core-tables)
3. [Discord Integration Tables](#discord-integration-tables)
4. [Announcement Tables](#announcement-tables)
5. [Indexes](#indexes)
6. [Triggers](#triggers)
7. [Functions](#functions)
8. [Relationships](#relationships)

---

## Overview

Commentum Shelby uses a PostgreSQL database with the following table structure:

- **Core Tables**: mod_plus, users, media, comments
- **Discord Integration**: discord_users, discord_notifications
- **Announcement System**: announcements, announcement_reads, announcement_views

### Database Design Principles

1. **Single Source of Truth**: Roles in `mod_plus`, user status in `users`
2. **Minimal Redundancy**: Only cache necessary data in comments
3. **Foreign Key Constraints**: Maintain referential integrity
4. **Indexing Strategy**: Optimize for common query patterns
5. **Timestamp Tracking**: All tables have created_at and updated_at

---

## Core Tables

### mod_plus

Centralized role management table.

**Purpose**: Store user roles for moderation and administration

**Schema**:
```sql
CREATE TABLE mod_plus (
  user_id TEXT NOT NULL,
  username TEXT NOT NULL,
  role TEXT NOT NULL CHECK (role IN ('moderator', 'admin', 'super_admin')),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT mod_plus_pkey PRIMARY KEY (user_id)
);
```

**Columns**:
- `user_id` (TEXT, PRIMARY KEY): User ID from platform (AniList/MAL/SIMKL)
- `username` (TEXT): Display username
- `role` (TEXT): 'moderator', 'admin', or 'super_admin'
- `created_at` (TIMESTAMPTZ): Record creation time
- `updated_at` (TIMESTAMPTZ): Last update time

**Constraints**:
- Primary key on `user_id`
- Role must be one of: 'moderator', 'admin', 'super_admin'

**Indexes**: None (primary key sufficient)

**Common Queries**:
```sql
-- Get user role
SELECT role FROM mod_plus WHERE user_id = '12345';

-- Get all moderators
SELECT * FROM mod_plus WHERE role = 'moderator';

-- Check if user is moderator
SELECT EXISTS(SELECT 1 FROM mod_plus WHERE user_id = '12345' AND role IN ('moderator', 'admin', 'super_admin'));
```

---

### users

Minimal user information with centralized status tracking.

**Purpose**: Store user status (banned, muted, warned) across all platforms

**Schema**:
```sql
CREATE TABLE users (
  user_id TEXT NOT NULL,
  username TEXT NOT NULL,
  client_type TEXT NOT NULL CHECK (client_type IN ('anilist', 'myanimelist', 'simkl', 'other')),
  user_banned BOOLEAN DEFAULT FALSE,
  user_muted_until TIMESTAMPTZ,
  user_shadow_banned BOOLEAN DEFAULT FALSE,
  user_warnings INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT users_pkey PRIMARY KEY (user_id, client_type),
  CONSTRAINT username_length CHECK (length(username) >= 1 AND length(username) <= 50)
);
```

**Columns**:
- `user_id` (TEXT, PRIMARY KEY part 1): User ID from platform
- `username` (TEXT): Display username (1-50 characters)
- `client_type` (TEXT, PRIMARY KEY part 2): Platform type
- `user_banned` (BOOLEAN): Ban status
- `user_muted_until` (TIMESTAMPTZ): Mute expiration time (null = not muted)
- `user_shadow_banned` (BOOLEAN): Shadow ban status
- `user_warnings` (INTEGER): Warning count
- `created_at` (TIMESTAMPTZ): Record creation time
- `updated_at` (TIMESTAMPTZ): Last update time

**Constraints**:
- Composite primary key on `(user_id, client_type)`
- Username must be 1-50 characters
- Client type must be valid platform

**Indexes**:
```sql
CREATE INDEX idx_users_client_user ON users(client_type, user_id);
```

**Common Queries**:
```sql
-- Check user status
SELECT * FROM users WHERE user_id = '12345' AND client_type = 'anilist';

-- Check if user is banned
SELECT user_banned FROM users WHERE user_id = '12345' AND client_type = 'anilist';

-- Check if user is muted
SELECT user_muted_until > NOW() as is_muted FROM users WHERE user_id = '12345' AND client_type = 'anilist';

-- Get users with high warning counts
SELECT * FROM users WHERE user_warnings >= 5 ORDER BY user_warnings DESC;
```

---

### media

Centralized media information.

**Purpose**: Cache media metadata from external APIs (AniList, MAL, SIMKL)

**Schema**:
```sql
CREATE TABLE media (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  media_id TEXT NOT NULL,
  client_type TEXT NOT NULL CHECK (client_type IN ('anilist', 'myanimelist', 'simkl', 'other')),
  media_type TEXT NOT NULL CHECK (media_type IN ('anime', 'manga', 'movie', 'tv', 'other')),
  title TEXT NOT NULL,
  year INTEGER,
  poster TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT media_unique UNIQUE (media_id, client_type),
  CONSTRAINT title_length CHECK (length(title) >= 1 AND length(title) <= 200)
);
```

**Columns**:
- `id` (INTEGER, PRIMARY KEY): Auto-increment ID
- `media_id` (TEXT): Media ID from external API
- `client_type` (TEXT): Platform type
- `media_type` (TEXT): Type of media (anime, manga, etc.)
- `title` (TEXT): Media title (1-200 characters)
- `year` (INTEGER): Release year
- `poster` (TEXT): Poster image URL
- `created_at` (TIMESTAMPTZ): Record creation time
- `updated_at` (TIMESTAMPTZ): Last update time

**Constraints**:
- Primary key on `id`
- Unique constraint on `(media_id, client_type)`
- Title must be 1-200 characters

**Indexes**:
```sql
CREATE INDEX idx_media_client_media ON media(client_type, media_id);
```

**Common Queries**:
```sql
-- Get media by ID and platform
SELECT * FROM media WHERE media_id = '12345' AND client_type = 'anilist';

-- Search media by title
SELECT * FROM media WHERE title ILIKE '%Attack on Titan%';

-- Get recent media
SELECT * FROM media ORDER BY created_at DESC LIMIT 10;
```

---

### comments

Full comment data with moderation features.

**Purpose**: Store all comments with full moderation support

**Schema**:
```sql
CREATE TABLE comments (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  
  -- Core data
  user_id TEXT NOT NULL,
  client_type TEXT NOT NULL CHECK (client_type IN ('anilist', 'myanimelist', 'simkl', 'other')),
  media_id TEXT NOT NULL,
  content TEXT NOT NULL,
  
  -- User information (cached)
  username TEXT NOT NULL,
  user_role TEXT DEFAULT 'user' CHECK (user_role IN ('user', 'moderator', 'admin', 'super_admin')),
  
  -- Media information (cached)
  media_type TEXT NOT NULL CHECK (media_type IN ('anime', 'manga', 'movie', 'tv', 'other')),
  media_title TEXT NOT NULL,
  media_year INTEGER,
  media_poster TEXT,
  
  -- Comment structure
  parent_id INTEGER REFERENCES comments(id) ON DELETE CASCADE,
  
  -- Comment states
  deleted BOOLEAN DEFAULT FALSE,
  deleted_at TIMESTAMPTZ,
  deleted_by TEXT,
  
  pinned BOOLEAN DEFAULT FALSE,
  pinned_at TIMESTAMPTZ,
  pinned_by TEXT,
  
  locked BOOLEAN DEFAULT FALSE,
  locked_at TIMESTAMPTZ,
  locked_by TEXT,
  
  -- Edit tracking
  edited BOOLEAN DEFAULT FALSE,
  edited_at TIMESTAMPTZ,
  edit_count INTEGER DEFAULT 0,
  edit_history TEXT, -- JSON array
  
  -- Voting system
  upvotes INTEGER DEFAULT 0,
  downvotes INTEGER DEFAULT 0,
  vote_score INTEGER DEFAULT 0,
  user_votes TEXT, -- JSON object
  
  -- Reporting system
  reported BOOLEAN DEFAULT FALSE,
  report_count INTEGER DEFAULT 0,
  reports TEXT, -- JSON array
  report_status TEXT DEFAULT 'none' CHECK (report_status IN ('none', 'pending', 'reviewed', 'resolved', 'dismissed')),
  
  -- Content warnings
  tags TEXT, -- JSON array
  tagged_by TEXT,
  
  -- Moderation
  moderated BOOLEAN DEFAULT FALSE,
  moderated_at TIMESTAMPTZ,
  moderated_by TEXT,
  moderation_reason TEXT,
  moderation_action TEXT,
  
  -- System fields
  ip_address TEXT,
  user_agent TEXT,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Constraints
  CONSTRAINT content_length CHECK (length(content) >= 1 AND length(content) <= 10000),
  CONSTRAINT username_length CHECK (length(username) >= 1 AND length(username) <= 50)
);
```

**Columns**:

**Core Data**:
- `id` (INTEGER, PRIMARY KEY): Auto-increment ID
- `user_id` (TEXT): User ID from platform
- `client_type` (TEXT): Platform type
- `media_id` (TEXT): Media ID
- `content` (TEXT): Comment content (1-10000 characters)

**User Information (Cached)**:
- `username` (TEXT): User username (1-50 characters)
- `user_role` (TEXT): User role at time of comment

**Media Information (Cached)**:
- `media_type` (TEXT): Type of media
- `media_title` (TEXT): Media title
- `media_year` (INTEGER): Media release year
- `media_poster` (TEXT): Media poster URL

**Comment Structure**:
- `parent_id` (INTEGER): Parent comment ID (null = top-level)

**Comment States**:
- `deleted` (BOOLEAN): Soft delete flag
- `deleted_at` (TIMESTAMPTZ): Deletion time
- `deleted_by` (TEXT): User who deleted
- `pinned` (BOOLEAN): Pin flag
- `pinned_at` (TIMESTAMPTZ): Pin time
- `pinned_by` (TEXT): User who pinned
- `locked` (BOOLEAN): Lock flag (no replies)
- `locked_at` (TIMESTAMPTZ): Lock time
- `locked_by` (TEXT): User who locked

**Edit Tracking**:
- `edited` (BOOLEAN): Edit flag
- `edited_at` (TIMESTAMPTZ): Last edit time
- `edit_count` (INTEGER): Number of edits
- `edit_history` (TEXT): JSON array of edit history

**Voting System**:
- `upvotes` (INTEGER): Upvote count
- `downvotes` (INTEGER): Downvote count
- `vote_score` (INTEGER): Net score (upvotes - downvotes)
- `user_votes` (TEXT): JSON object of user votes

**Reporting System**:
- `reported` (BOOLEAN): Report flag
- `report_count` (INTEGER): Number of reports
- `reports` (TEXT): JSON array of reports
- `report_status` (TEXT): Report status

**Content Warnings**:
- `tags` (TEXT): JSON array of tags
- `tagged_by` (TEXT): User who tagged

**Moderation**:
- `moderated` (BOOLEAN): Moderation action flag
- `moderated_at` (TIMESTAMPTZ): Moderation time
- `moderated_by` (TEXT): User who moderated
- `moderation_reason` (TEXT): Reason for moderation
- `moderation_action` (TEXT): Action taken

**System Fields**:
- `ip_address` (TEXT): User IP address
- `user_agent` (TEXT): User browser string

**Timestamps**:
- `created_at` (TIMESTAMPTZ): Creation time
- `updated_at` (TIMESTAMPTZ): Last update time

**Constraints**:
- Primary key on `id`
- Foreign key `parent_id` references `comments(id)` with cascade delete
- Content must be 1-10000 characters
- Username must be 1-50 characters

**Indexes**:
```sql
CREATE INDEX idx_comments_client_user ON comments(client_type, user_id);
CREATE INDEX idx_comments_media ON comments(media_id, client_type);
CREATE INDEX idx_comments_parent ON comments(parent_id);
CREATE INDEX idx_comments_created ON comments(created_at DESC);
CREATE INDEX idx_comments_deleted ON comments(deleted);
CREATE INDEX idx_comments_role ON comments(user_role);
CREATE INDEX idx_comments_report_status ON comments(report_status);
CREATE INDEX idx_comments_pinned ON comments(pinned);
CREATE INDEX idx_comments_locked ON comments(locked);
CREATE INDEX idx_comments_vote_score ON comments(vote_score);
```

**Common Queries**:
```sql
-- Get comments for media
SELECT * FROM comments WHERE media_id = '12345' AND client_type = 'anilist' AND deleted = FALSE;

-- Get top comments
SELECT * FROM comments WHERE media_id = '12345' AND client_type = 'anilist' ORDER BY vote_score DESC;

-- Get reported comments
SELECT * FROM comments WHERE reported = TRUE AND report_status = 'pending';

-- Get user comments
SELECT * FROM comments WHERE user_id = '12345' AND client_type = 'anilist' ORDER BY created_at DESC;

-- Get comment replies
SELECT * FROM comments WHERE parent_id = 123 ORDER BY created_at ASC;

-- Get pinned comments
SELECT * FROM comments WHERE pinned = TRUE ORDER BY pinned_at DESC;
```

---

## Discord Integration Tables

### discord_users

Discord user registration and mapping.

**Purpose**: Map Discord accounts to platform accounts

**Schema**:
```sql
CREATE TABLE discord_users (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Discord user information
  discord_user_id TEXT UNIQUE NOT NULL,
  discord_username TEXT NOT NULL,
  discord_discriminator TEXT,
  discord_avatar TEXT,
  
  -- Platform mapping
  platform_user_id TEXT NOT NULL,
  platform_type TEXT NOT NULL CHECK (platform_type IN ('anilist', 'myanimelist', 'simkl', 'other')),
  
  -- Role and permissions
  user_role TEXT NOT NULL DEFAULT 'user' CHECK (user_role IN ('user', 'moderator', 'admin', 'super_admin')),
  
  -- Registration status
  is_verified BOOLEAN DEFAULT FALSE,
  verified_at TIMESTAMPTZ,
  registered_at TIMESTAMPTZ DEFAULT NOW(),
  is_active BOOLEAN DEFAULT TRUE,
  
  -- Last activity
  last_command_at TIMESTAMPTZ,
  last_action_at TIMESTAMPTZ
);
```

**Columns**:
- `id` (INTEGER, PRIMARY KEY): Auto-increment ID
- `discord_user_id` (TEXT, UNIQUE): Discord user ID
- `discord_username` (TEXT): Discord username
- `discord_discriminator` (TEXT): Discord discriminator (#1234)
- `discord_avatar` (TEXT): Discord avatar hash
- `platform_user_id` (TEXT): Platform user ID
- `platform_type` (TEXT): Platform type
- `user_role` (TEXT): User role
- `is_verified` (BOOLEAN): Verification status
- `verified_at` (TIMESTAMPTZ): Verification time
- `registered_at` (TIMESTAMPTZ): Registration time
- `is_active` (BOOLEAN): Activity status
- `last_command_at` (TIMESTAMPTZ): Last command time
- `last_action_at` (TIMESTAMPTZ): Last action time

**Indexes**:
```sql
CREATE INDEX idx_discord_users_discord_id ON discord_users(discord_user_id);
CREATE INDEX idx_discord_users_platform ON discord_users(platform_type, platform_user_id);
CREATE INDEX idx_discord_users_role ON discord_users(user_role);
```

---

### discord_notifications

Discord notification delivery tracking.

**Purpose**: Track Discord webhook notifications

**Schema**:
```sql
CREATE TABLE discord_notifications (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Notification type and target
  notification_type TEXT NOT NULL,
  target_id TEXT,
  target_type TEXT,
  
  -- Related data
  comment_data TEXT,
  user_data TEXT,
  media_data TEXT,
  
  -- Discord delivery info
  guild_id TEXT,
  channel_id TEXT,
  message_id TEXT,
  delivery_status TEXT DEFAULT 'pending',
  delivery_error TEXT,
  delivered_at TIMESTAMPTZ,
  
  -- Retry info
  retry_count INTEGER DEFAULT 0,
  next_retry_at TIMESTAMPTZ
);
```

**Columns**:
- `id` (INTEGER, PRIMARY KEY): Auto-increment ID
- `notification_type` (TEXT): Type of notification
- `target_id` (TEXT): Target object ID
- `target_type` (TEXT): Target object type
- `comment_data` (TEXT): JSON comment data
- `user_data` (TEXT): JSON user data
- `media_data` (TEXT): JSON media data
- `guild_id` (TEXT): Discord guild ID
- `channel_id` (TEXT): Discord channel ID
- `message_id` (TEXT): Discord message ID
- `delivery_status` (TEXT): Delivery status
- `delivery_error` (TEXT): Error message if failed
- `delivered_at` (TIMESTAMPTZ): Delivery time
- `retry_count` (INTEGER): Number of retry attempts
- `next_retry_at` (TIMESTAMPTZ): Next retry time

**Indexes**:
```sql
CREATE INDEX idx_discord_notifications_type ON discord_notifications(notification_type);
CREATE INDEX idx_discord_notifications_status ON discord_notifications(delivery_status);
```

---

## Announcement Tables

### announcements

Multi-app announcement system.

**Purpose**: Store announcements for multiple apps

**Schema**:
```sql
CREATE TABLE announcements (
  id SERIAL PRIMARY KEY,
  
  -- App identification
  app_id VARCHAR(50) NOT NULL,
  
  -- Content
  title VARCHAR(200) NOT NULL,
  short_description VARCHAR(500) NOT NULL,
  full_content TEXT NOT NULL,
  
  -- Metadata
  author_id VARCHAR(100),
  author_name VARCHAR(100),
  
  -- Categorization
  category VARCHAR(50) DEFAULT 'general',
  priority INTEGER DEFAULT 0,
  
  -- Targeting
  target_roles TEXT[],
  target_platforms TEXT[],
  
  -- Status
  status VARCHAR(20) DEFAULT 'draft' CHECK (status IN ('draft', 'published', 'archived')),
  pinned BOOLEAN DEFAULT FALSE,
  featured BOOLEAN DEFAULT FALSE,
  
  -- Timestamps
  published_at TIMESTAMPTZ,
  expires_at TIMESTAMPTZ,
  
  -- Tracking
  view_count INTEGER DEFAULT 0,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  CONSTRAINT announcements_valid_status CHECK (status IN ('draft', 'published', 'archived'))
);
```

**Indexes**:
```sql
CREATE INDEX idx_announcements_app_id ON announcements(app_id);
CREATE INDEX idx_announcements_status ON announcements(status);
CREATE INDEX idx_announcements_published_at ON announcements(published_at DESC);
CREATE INDEX idx_announcements_app_status ON announcements(app_id, status);
CREATE INDEX idx_announcements_pinned ON announcements(pinned DESC, priority DESC, published_at DESC);
CREATE INDEX idx_announcements_category ON announcements(app_id, category);
```

---

### announcement_reads

User read status tracking.

**Purpose**: Track which users have read which announcements

**Schema**:
```sql
CREATE TABLE announcement_reads (
  id SERIAL PRIMARY KEY,
  announcement_id INTEGER REFERENCES announcements(id) ON DELETE CASCADE,
  user_id VARCHAR(100) NOT NULL,
  app_id VARCHAR(50) NOT NULL,
  read_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(announcement_id, user_id, app_id)
);
```

**Indexes**:
```sql
CREATE INDEX idx_announcement_reads_user ON announcement_reads(user_id, app_id);
CREATE INDEX idx_announcement_reads_announcement ON announcement_reads(announcement_id);
```

---

### announcement_views

Detailed view tracking for analytics.

**Purpose**: Track all announcement views (including anonymous)

**Schema**:
```sql
CREATE TABLE announcement_views (
  id SERIAL PRIMARY KEY,
  announcement_id INTEGER REFERENCES announcements(id) ON DELETE CASCADE,
  user_id VARCHAR(100),
  app_id VARCHAR(50) NOT NULL,
  viewed_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Indexes**:
```sql
CREATE INDEX idx_announcement_views_announcement ON announcement_views(announcement_id);
```

---

## Indexes

### Performance Indexes

```sql
-- Users table
CREATE INDEX idx_users_client_user ON users(client_type, user_id);

-- Media table
CREATE INDEX idx_media_client_media ON media(client_type, media_id);

-- Comments table
CREATE INDEX idx_comments_client_user ON comments(client_type, user_id);
CREATE INDEX idx_comments_media ON comments(media_id, client_type);
CREATE INDEX idx_comments_parent ON comments(parent_id);
CREATE INDEX idx_comments_created ON comments(created_at DESC);
CREATE INDEX idx_comments_deleted ON comments(deleted);
CREATE INDEX idx_comments_role ON comments(user_role);
CREATE INDEX idx_comments_report_status ON comments(report_status);
CREATE INDEX idx_comments_pinned ON comments(pinned);
CREATE INDEX idx_comments_locked ON comments(locked);
CREATE INDEX idx_comments_vote_score ON comments(vote_score);

-- Discord tables
CREATE INDEX idx_discord_users_discord_id ON discord_users(discord_user_id);
CREATE INDEX idx_discord_users_platform ON discord_users(platform_type, platform_user_id);
CREATE INDEX idx_discord_users_role ON discord_users(user_role);
CREATE INDEX idx_discord_notifications_type ON discord_notifications(notification_type);
CREATE INDEX idx_discord_notifications_status ON discord_notifications(delivery_status);

-- Announcement tables
CREATE INDEX idx_announcements_app_id ON announcements(app_id);
CREATE INDEX idx_announcements_status ON announcements(status);
CREATE INDEX idx_announcements_published_at ON announcements(published_at DESC);
CREATE INDEX idx_announcements_app_status ON announcements(app_id, status);
CREATE INDEX idx_announcements_pinned ON announcements(pinned DESC, priority DESC, published_at DESC);
CREATE INDEX idx_announcements_category ON announcements(app_id, category);
CREATE INDEX idx_announcement_reads_user ON announcement_reads(user_id, app_id);
CREATE INDEX idx_announcement_reads_announcement ON announcement_reads(announcement_id);
CREATE INDEX idx_announcement_views_announcement ON announcement_views(announcement_id);
```

---

## Triggers

### Updated At Trigger

Automatically update `updated_at` timestamp on all tables.

```sql
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

**Applied to tables**:
```sql
CREATE TRIGGER update_mod_plus_updated_at
  BEFORE UPDATE ON mod_plus
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_users_updated_at
  BEFORE UPDATE ON users
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_media_updated_at
  BEFORE UPDATE ON media
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_discord_users_updated_at
  BEFORE UPDATE ON discord_users
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_announcements_updated_at
  BEFORE UPDATE ON announcements
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_comments_updated_at
  BEFORE UPDATE ON comments
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

---

## Functions

### get_comment_depth

Get the depth of a comment (how many levels of nesting).

**Purpose**: Calculate comment nesting level for reply depth limits

**Definition**:
```sql
CREATE OR REPLACE FUNCTION get_comment_depth(comment_id INTEGER)
RETURNS INTEGER AS $$
WITH RECURSIVE comment_tree AS (
  SELECT id, parent_id, 0 as depth
  FROM comments
  WHERE id = comment_id
  
  UNION ALL
  
  SELECT c.id, c.parent_id, ct.depth + 1
  FROM comments c
  INNER JOIN comment_tree ct ON c.id = ct.parent_id
)
SELECT MAX(depth) FROM comment_tree;
$$ LANGUAGE sql;
```

**Usage**:
```sql
-- Get depth of comment 123
SELECT get_comment_depth(123);

-- Check if comment exceeds max depth
SELECT get_comment_depth(123) >= 10 as exceeds_max_depth;
```

---

## Relationships

### ER Diagram

```
mod_plus (user_id)
    ↓ (one-to-one)
users (user_id, client_type)
    ↓
comments (user_id, client_type)

media (media_id, client_type)
    ↓ (one-to-many)
comments (media_id, client_type)

comments (id)
    ↓ (self-referencing)
comments (parent_id)

discord_users (platform_user_id, platform_type)
    ↓ (maps to)
users (user_id, client_type)

announcements (id)
    ↓ (one-to-many)
announcement_reads (announcement_id)
announcement_views (announcement_id)
```

### Key Relationships

1. **mod_plus → users**: One-to-one via user_id
2. **users → comments**: One-to-many via user_id + client_type
3. **media → comments**: One-to-many via media_id + client_type
4. **comments → comments**: Self-referencing via parent_id
5. **discord_users → users**: Maps discord_users.platform_user_id + platform_type to users.user_id + client_type
6. **announcements → announcement_reads**: One-to-many via announcement_id
7. **announcements → announcement_views**: One-to-many via announcement_id

---

## Additional Resources

- [API Reference](./api-reference.md) - API endpoint documentation
- [Configuration Guide](./configuration.md) - Environment variables
- [Deployment Guide](./deployment.md) - Deployment instructions
- [Discord Bot Guide](./discord-bot.md) - Discord integration details
